# vue3.0都有哪些变化

## 源码优化

相对于2.x的源码组织，3.x的代码用monorepo把这些模块拆分到不同的package中，每个package有各自的API、类型定义和测试，这样使得模块拆分更细化，职责划分更明确，模块之间的依赖关系也更加明确，开发人员也更容易阅读、理解和更改所有模块源码，提高代码的可维护性。

package是可以独立于vue.js使用，这样用户如果只想要使用vue.js的响应式能力，可单独依赖这个响应式库而不用去依赖整合vue.js，减少了应用包的体积大小，而2.x的版本是做不到这一点的

另外编写语言也由flow改为了typescript

## 性能优化

数据劫持优化，当数据改变后，为了自动更新DOM，那么就必须劫持数据的更新，也就是说当数据发生改变后能自动执行代码去更新DOM。

通过object.defineProperty这个API的劫持数据的getter和setter，必须知道拦截的key是什么，前提层级比较深的对象3.x书提包费proxy api劫持振哥对象，但是proxy api并不能监听到内部深层次对象的变化，因此3.x的处理方式是在getter中去递归响应式，这样的好处是真正的访问内部对象才会变成响应式，而不是无脑的递归全集，这样在很大程度上提升了性能

## 编译优化

通过在编译阶段优化编译结果，实现运行时patch过程的优化。

通过编译阶段对静态模板的分析，编译生产了block tree。block tree是一个将模板基于动态节点指令切割的嵌套区块，每个区块内部的节点结构是固定的，每个区块只需要以一个array来追踪自身包含的动态节点。

借助blcok tree，vue.js将vnode更新性能由模板整体大小相关提示为动态内容的数量相关

## 优化逻辑组织

2.x编写组件本质就是在编写一个抱哈了描述组件选项的对象，我们称它为options API

options API按照methods,computed,data,props这些不同的选项分类，组件小的时候，这种方式一目了然，但大型组件，一个组件可能有多个逻辑关注点，当使用options API的时候，每个关注点都有自己的options。

3.x提供了新的api（compsositon api），就是将某个逻辑的关注点相关的代码全都放进一个函数里，这样当需要修改一个功能时，就不需要在文件夹中跳来跳去。

## 优化逻辑复用

每个mixin都可以定义自己的props,data他们之间无感，所以很容易定义相同的变量，导致命名冲突。对组件而言,如果模板中使用不在当前组件中定义的变量，那么就会不太容易知道这些变量在哪定义的，这就是数据来源不清晰

## 引入RFC
